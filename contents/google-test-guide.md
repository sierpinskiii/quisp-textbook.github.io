Your first mission: Google Test
QuISP is a huge program, and it is built with various components, made with everyone’s effort. Understanding all of them at once is not a very efficient idea for beginners. We have to set the starting point, and make some checkpoints to make progress by time. Now, when you first try contributing to QuISP, it’s pretty difficult to decide where to start working. Some issues on GitHub require some prerequisite knowledge. 

However, we are humans (and cats, we assume), and 「Divide & Conquer」is one of humanity's most powerful traits. Therefore, we are going to divide each component of QuISP, and understand them step by step. This technique is not just for learners; if you are an experienced developer, you must have some experience of writing unit tests. To maintain the entire program efficiently and safely, it’s important to make use of unit tests to keep on track of every component.

In the medium post “Introduction to Google Test: An Open Source C/C++ Unit-Testing Framework,” Eldad Uzman emphasizes the importance of unit testing: “It provides software developers fast feedback about their code at a fine-grained level.” Now pay attention to the keyword, “fast feedback.” In a huge project like QuISP, it’s sometimes not easy to track the difference made to the project, despite its importance. However, with unit tests, contributors can get the “fast feedback” of the work they’ve done. This is why we’re highly prioritizing the unit test for everyone.

Enough talks. Let’s dive into the testing part.
There is an issue #510 in the repository, which is already closed at this point: “Unit tests for Runtime Instructions,” written by our core developer, whit3z. While this is already a closed project, this is a pretty good issue to work on. We are going to clone the repository of QuISP and rollback to the moment before the PR resolving this issue was merged. There is a branch for practicing this issue solving, so let’s checkout into the ‘textbook-ch1-unit-test’ branch.

Now, this issue is asking us to write the good unit tests for each functions of ‘Runtime Instructions,’ which takes place in the ‘/quisp/runtime/def_instructions.h’ and ‘/quisp/runtime/InstructionVisitor.cc’. Most of the functions are predefined in the header file ‘def_instructions.h’, and the behavior of them are described in the file ‘InstructionVisitor.cc’.
Our mission is to write the proper unit testing functions for each of these Instruction Visitor functions inside the existing file ‘/quisp/runtime/Runtime_instructions_test.cc’.

If you open the ‘Runtime_instructions_test.cc’, you’ll see the file already containing several unit test functions. But before we move on, we need to make sure that you understand the concept of Runtime Instructions. This might take a while, so go grab your caffeine or something.

Meet the Ruleset
Ruleset is one of the most important components (and concept) you’ll meet while working with QuISP. Since we are dealing with a huge Quantum Networks, we have to think carefully about the messaging protocol for all of the nodes in the network. Obviously, each node will not receive a message from just another single node. Many of them are connected with more than two nodes. There will be various types of messages incoming at various moments with all the different contents. We can think of the Quantum Network as a single Philharmonic Orchestra, each node corresponding to the players of the orchestra. 

…and every orchestra needs a conductor.

The conductor takes care of every player and gives a signal for them so that they can all start at the same time and keep the sync between them. Even the most skilled violinist cannot play in sync with every other member of the orchestra without the signal of the conductor. This is exactly what Ruleset does in the Quantum Network. The only difference is that our conductor is not a single node in the network, but a set of extremely accurate promises and schedules about when to start playing and when to stop and listen. While most ‘human musicians’ cannot keep in sync with these types of promises and schedules (have you ever seen the orchestra without a conductor, but everyone with a huge chronometer?), we all know that computers are specialized for this sort of job.



Another good thing about Ruleset is that it is dynamic. You might think of Ruleset as something defined/generated by developers or users, but it isn’t. We only define ‘the logic’ to generate an appropriate Ruleset for every situation. “So you ARE generating the Ruleset using the logic you defined, isn’t it?” you might ask, but that “would fall within the purview of your conundrums of philosophy,” so let’s just say it’s generated by computers, using the procedure defined by humans.
RuleEngine and Runtime
Here is the top-level code of the logic we use to generate our Rulesets, but it doesn’t give us much idea about how each node processes the Ruleset. As mentioned above, the Ruleset is dynamic, and the ‘Runtime’ of each node continuously refers to the Ruleset to decide its next action, like you referring to Google Maps everywhere you go. The Runtime works as the main function of each node. 

Runtime will send the information of the surrounding network situation to the RuleSet, and ask for the appropriate next step.
Ruleset responds with the instruction to follow.
Runtime executes the RuleEngine to decode the instruction.
RuleEngine will generate the appropriate message to send (if there is any).
And then the Runtime will send that message to the proper opponent.



